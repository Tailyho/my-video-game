<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Видео + 3D-пчела</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
    }
    
    .video-container {
      width: 100%;
      max-width: 600px;
      margin: 40px auto;
      text-align: center;
    }
    
    video {
      width: 100%;
      display: block;
    }
    
    #world {
      width: 100%;
      height: 500px; /* Высота 3D-сцены */
      margin: 80px auto; /* Отступ от видео */
      background-color: #f0f0f0; /* Фоновый цвет (можно убрать) */
    }
  </style>
</head>
<body>
  <div class="video-container">
    <h2>Видео (удерживайте мышь для воспроизведения)</h2>
    <video
      id="myVideo"
      src="https://raw.githubusercontent.com/Tailyho/my-video-game/main/talar%20(online-video-cutter.com).mp4"
      playsinline
    ></video>
  </div>

  <!-- Здесь будет 3D-сцена с пчелой -->
  <div id="world"></div>

  <!-- Подключаем библиотеки -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/95/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>

  <script>
    // Ваш код Three.js (ниже)
    const colors = {
      green: 0x2bca2b,
      black: 0x333359,
      white: 0xd8d0d1,
      pink: 0xf5986e,
      blue: 0x68c3c0,
      grey: 0x5f5f5f,
      yellow: 0xe7af11
    };

    let mousePos = { x: 0, y: 0 };
    let scene, fieldOfView, aspectRatio, renderer, from, to, camera, container;
    let bee;
    let HEIGHT, WIDTH;
    let score = 0;
    let level = 0;
    let dead = false;
    let speedFactor = 0;
    const target = new THREE.Vector3();
    let ambientLight, hemisphereLight, shadowLight;

    window.addEventListener('load', init, false);

    function init() {
      createScene();
      createLights();
      createBee();

      document.addEventListener('mousemove', handleMouseMove, false);
      
      // Добавляем прослушиватель окончания видео
      const video = document.getElementById('myVideo');
      video.addEventListener('ended', () => {
        console.log('Видео завершено. Прокручиваем к 3D-сцене...');
        document.getElementById('world').scrollIntoView({ behavior: 'smooth' });
      });

      loop();
    }

    // Handle touch/mobile
    const myElement = document.getElementById('js-touch') || document.body;
    const mc = new Hammer(myElement);

    function createScene() {
      HEIGHT = window.innerHeight;
      WIDTH = window.innerWidth;

      scene = new THREE.Scene();
      aspectRatio = WIDTH / HEIGHT;
      fieldOfView = 35;
      from = 1;
      to = 1000;

      camera = new THREE.PerspectiveCamera(fieldOfView, aspectRatio, from, to);
      scene.fog = new THREE.Fog(colors.grey, 100, 1000);

      camera.position.x = 0;
      camera.position.z = 220;
      camera.position.y = 150;
      camera.rotation.x = -Math.PI / 6;

      renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setSize(WIDTH, HEIGHT);
      renderer.shadowMap.enabled = true;

      container = document.getElementById('world');
      container.appendChild(renderer.domElement);

      window.addEventListener('resize', handleWindowResize, false);
    }

    function createLights() {
      hemisphereLight = new THREE.HemisphereLight(0xaaaaaa, 0x000000, 0.9);
      shadowLight = new THREE.DirectionalLight(0xffffff, 0.6);
      shadowLight.position.set(150, 490, 350);
      shadowLight.castShadow = true;
      shadowLight.shadow.camera.left = -400;
      shadowLight.shadow.camera.right = 400;
      shadowLight.shadow.camera.top = 400;
      shadowLight.shadow.camera.bottom = -400;
      shadowLight.shadow.camera.near = 1;
      shadowLight.shadow.camera.far = 1000;
      shadowLight.shadow.mapSize.width = 2048;
      shadowLight.shadow.mapSize.height = 2048;

      ambientLight = new THREE.AmbientLight(0xff8d8d, 0.9);

      scene.add(ambientLight);
      scene.add(hemisphereLight);
      scene.add(shadowLight);
    }

    function createBee() {
      bee = new Bee();
      bee.mesh.scale.set(0.25, 0.25, 0.25);
      bee.mesh.position.y = 0;
      bee.mesh.position.z = 0;
      scene.add(bee.mesh);
    }

    function handleWindowResize() {
      HEIGHT = window.innerHeight;
      WIDTH = window.innerWidth;

      renderer.setSize(WIDTH, HEIGHT);
      camera.aspect = WIDTH / HEIGHT;
      camera.updateProjectionMatrix();
    }

    function handleMouseMove(event) {
      const tx = -1 + event.clientX / WIDTH * 2;
      const ty = 1 - event.clientY / HEIGHT * 2;

      mousePos = { x: tx, y: ty };
    }

    function getRandomInt(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min)) + min;
    }

    function normalize(v, vmin, vmax, tmin, tmax) {
      const nv = Math.max(Math.min(v, vmax), vmin);
      const dv = vmax - vmin;
      const pc = (nv - vmin) / dv;
      const dt = tmax - tmin;
      const tv = tmin + pc * dt;
      return tv;
    }

    let Bee = function() {
      this.mesh = new THREE.Object3D();

      // HEAD
      const geomHead = new THREE.SphereGeometry(55, 32, 32);
      const matHead = new THREE.MeshPhongMaterial({
        color: colors.black,
        flatShading: THREE.FlatShading
      });
      this.head = new THREE.Mesh(geomHead, matHead);
      this.head.castShadow = true;
      this.head.receiveShadow = true;
      this.head.position.z -= 130;
      this.head.position.y -= 10;
      this.mesh.add(this.head);

      // BODY1
const geomBody1 = new THREE.SphereGeometry(65, 32, 32);
const matBody1 = new THREE.MeshPhongMaterial({
  color: colors.yellow,
  flatShading: THREE.FlatShading
});

this.body1 = new THREE.Mesh(geomBody1, matBody1);
this.body1.castShadow = true;
this.body1.receiveShadow = true;
this.body1.position.z = -100;
this.mesh.add(this.body1);

// BODY2
const geomBody2 = new THREE.SphereGeometry(70, 32, 32);
const matBody2 = new THREE.MeshPhongMaterial({
  color: colors.black,
  flatShading: THREE.FlatShading
});

this.body2 = new THREE.Mesh(geomBody2, matBody2);
this.body2.castShadow = true;
this.body2.receiveShadow = true;
this.body2.position.z -= 70;
this.mesh.add(this.body2);

// BODYWING (дополнительное «крылышко» на теле)
const geomBodyWing = new THREE.SphereGeometry(30, 32, 32);
const matBodyWing = new THREE.MeshPhongMaterial({
  color: colors.black,
  flatShading: THREE.FlatShading
});

this.bodyWing = new THREE.Mesh(geomBodyWing, matBodyWing);
this.bodyWing.castShadow = true;
this.bodyWing.receiveShadow = true;
this.bodyWing.position.z -= 70;
this.bodyWing.position.y += 50;
this.mesh.add(this.bodyWing);


// BODY3
const geomBody3 = new THREE.SphereGeometry(65, 32, 32);
const matBody3 = new THREE.MeshPhongMaterial({
  color: colors.yellow,
  flatShading: THREE.FlatShading
});

this.body3 = new THREE.Mesh(geomBody3, matBody3);
this.body3.castShadow = true;
this.body3.receiveShadow = true;
this.body3.position.z -= 40;
this.mesh.add(this.body3);


// TAIL
const geomTail = new THREE.SphereGeometry(45, 32, 32);
const matTail = new THREE.MeshPhongMaterial({
  color: colors.black,
  flatShading: THREE.FlatShading
});

this.tail = new THREE.Mesh(geomTail, matTail);
this.tail.castShadow = true;
this.tail.receiveShadow = true;
this.tail.position.z = 0;
this.head.position.y -= 10; // Корректировка позиции головы
this.mesh.add(this.tail);


// WINGS (крылья)
const geomWing = new THREE.Geometry();

// Вершины для левого крыла
geomWing.vertices.push(new THREE.Vector3(150, 100, -100));
geomWing.vertices.push(new THREE.Vector3(200, 100, 50));
geomWing.vertices.push(new THREE.Vector3(150, 100, 150));
geomWing.vertices.push(new THREE.Vector3(0, 0, 0));


// Вершины для правого крыла
geomWing.vertices.push(new THREE.Vector3(-150, 100, -100));
geomWing.vertices.push(new THREE.Vector3(-200, 100, 50));
geomWing.vertices.push(new THREE.Vector3(-150, 100, 150));
geomWing.vertices.push(new THREE.Vector3(0, 0, 0));


// Грани для левого крыла
geomWing.faces.push(new THREE.Face3(0, 1, 2));
geomWing.faces.push(new THREE.Face3(0, 3, 2));


geomWing.faces.push(new THREE.Face3(4, 5, 6));  // Треугольник 1
geomWing.faces.push(new THREE.Face3(4, 7, 6));  // Треугольник 2 (вершина 7 вместо 4)



const material = new THREE.MeshBasicMaterial({
  color: colors.white,
  transparent: true,
  opacity: 0.5,
  side: THREE.DoubleSide
});

this.wings = new THREE.Mesh(geomWing, material);
this.wings.castShadow = true;
this.wings.receiveShadow = true;
this.wings.position.x = 0;
this.wings.position.y = 75;
this.wings.position.z = -65;
this.mesh.add(this.wings);

// STING (жало)
const geomSting = new THREE.CylinderGeometry(20, 0, 50, 10);
const matSting = new THREE.MeshPhongMaterial({
  color: colors.white,
  flatShading: THREE.FlatShading
});


this.sting = new THREE.Mesh(geomSting, matSting);
this.sting.castShadow = true;
this.sting.receiveShadow = true;
this.sting.position.z += 50;
this.sting.position.y -= 10;
this.sting.rotation.x = Math.PI * 1.6;
this.mesh.add(this.sting);
};

// =============================
// ====== COLLISION LOGIC ======
// =============================
function checkCollision(coin, bee, distance) {
  return coin.z >= bee.z - distance && coin.z <= bee.z + distance &&
         coin.x >= bee.x - distance && coin.x <= bee.x + distance &&
         coin.y >= bee.y - distance && coin.y <= bee.y + distance;
}

function handleCollision(speed) {
  // Здесь логика обработки столкновений (монеты, бомбы)
  // Пока оставлено как заглушка
}

// =============================
// ======= UPDATE LOGIC ========
// =============================
function updateBee() {
  const targetX = normalize(mousePos.x, -1, 1, -100, 100);
  let targetZ = normalize(mousePos.y, -1, 1, 100, -200);

  // Плавное перемещение пчелы по X и Z
  bee.mesh.position.x += (targetX - bee.mesh.position.x / 2) * 0.2;
  bee.mesh.position.z += (targetZ - bee.mesh.position.z) * 0.2;

  // Наклоны при движении
  bee.mesh.rotation.x -= mousePos.y / 2;
  bee.mesh.rotation.x = (targetZ - bee.mesh.position.z) * 0.015;
  bee.mesh.rotation.y = (targetX - bee.mesh.position.x / 1.5) * -0.01;
  bee.mesh.rotation.z = (targetX - bee.mesh.position.x / 1.5) * -0.01;

  // Ограничение по Z (чтобы пчела не улетала слишком далеко)
  if (targetZ > 0) {
    targetZ = 0;
  } else if (targetZ < -150) {
    targetZ = -150;
  }

  let normalisedSpeed = Math.sqrt(targetZ * targetZ);

  if (bee.wings.geometry.vertices[0].y < 0 || bee.wings.geometry.vertices[0].y > 200) {
    normalisedSpeed *= -1;
  }

  // Анимация крыльев (колебание вершин)
  bee.wings.geometry.vertices[0].y -= normalisedSpeed;
  bee.wings.geometry.vertices[1].y -= normalisedSpeed;
  bee.wings.geometry.vertices[2].y -= normalisedSpeed;

  bee.wings.geometry.vertices[3].y -= normalisedSpeed;

  bee.wings.geometry.vertices[4].y -= normalisedSpeed;
bee.wings.geometry.vertices[5].y -= normalisedSpeed;
bee.wings.geometry.vertices[6].y -= normalisedSpeed;

// Флаг, сообщающий рендереру, что вершины изменились
bee.wings.geometry.verticesNeedUpdate = true;

// Дополнительно: пересчёт нормалей для корректного освещения
bee.wings.geometry.computeFaceNormals();
bee.wings.geometry.computeVertexNormals();
}

function loop() {
  renderer.render(scene, camera);
  updateBee();
  
  // Если пчела «погибла», не продолжаем анимацию
  if (!dead) {
    requestAnimationFrame(loop);
  }
}

// -----------------------------
// ДОПОЛНИТЕЛЬНЫЕ УЛУЧШЕНИЯ
// -----------------------------

// 1. Обработка изменения размера окна
window.addEventListener('resize', () => {
  handleWindowResize();
  
  // Пересчитываем aspectRatio и обновляем проекцию камеры
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  
  // Обновляем размер рендерера
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// 2. Плавное появление сцены (опционально)
function fadeInScene() {
  const sceneElement = document.getElementById('world');
  sceneElement.style.opacity = 0;
  sceneElement.style.transition = 'opacity 1s ease-in-out';
  
  setTimeout(() => {
    sceneElement.style.opacity = 1;
  }, 100);
}

function loop() {
  renderer.render(scene, camera);
  updateBee();
  if (!dead) {
    requestAnimationFrame(loop);
  }
}

// Инициализация при загрузке окна
window.addEventListener('load', init, false);

</script>
